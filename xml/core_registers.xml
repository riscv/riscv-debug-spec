<registers name="Core Debug Registers" prefix="CSR_">
    These registers are only accessible from Debug Mode.
    <register name="Debug Control and Status" short="dcsr" address="0x7b0">
        <field name="xdebugver" bits="31:28" access="R" reset="Preset">
          0: There is no external debug support.

          4: External debug support exists as it is described in this document.

          15: There is external debug support, but it does not conform to any
          available version of this spec.
        </field>
        <field name="0" bits="27:16" access="R" reset="0" />
        <field name="ebreakm" bits="15" access="R/W" reset="0">
            When 1, {\tt ebreak} instructions in Machine Mode enter Debug Mode.
        </field>
        <field name="0" bits="14" access="R" reset="0" />
        <field name="ebreaks" bits="13" access="R/W" reset="0">
            When 1, {\tt ebreak} instructions in Supervisor Mode enter Debug Mode.
        </field>
        <field name="ebreaku" bits="12" access="R/W" reset="0">
            When 1, {\tt ebreak} instructions in User/Application Mode enter
            Debug Mode.
        </field>
        <field name="stepie" bits="11" access="R/W" reset="0">
            0: Interrupts are disabled during single stepping.

            1: Interrupts are enabled during single stepping.

            Implementations may hard wire this bit to 0.
            The debugger must read back the value it
            writes to check whether the feature is supported. If not
            supported, interrupt behavior can be emulated by the debugger.
        </field>
        <field name="stopcount" bits="10" access="R/W" reset="Preset">

            0: Increment counters as usual.

            1: Don't increment any counters while in Debug Mode or on {\tt
            ebreak} instructions that cause entry into Debug Mode.  These
            counters include the {\tt cycle} and {\tt instret} CSRs. This is
            preferred for most debugging scenarios.

            An implementation may choose not to support writing to this bit.
            The debugger must read back the value it writes to check whether
            the feature is supported.

        </field>
        <field name="stoptime" bits="9" access="R/W" reset="Preset">
            0: Increment timers as usual.

            1: Don't increment any hart-local timers while in Debug Mode.

            An implementation may choose not to support writing to this bit.
            The debugger must read back the value it writes to check whether
            the feature is supported.

        </field>
        <field name="cause" bits="8:6" access="R" reset="0">
            Explains why Debug Mode was entered.

            When there are multiple reasons to enter Debug Mode in a single
            cycle, the cause with the highest priority is the one written.

            1: An {\tt ebreak} instruction was executed. (priority 3)

            2: The Trigger Module caused a breakpoint exception. (priority 4)

            3: The debugger requested entry to Debug Mode. (priority 2)

            4: The hart single stepped because \Fstep was set. (priority 1)

            Other values are reserved for future use.
        </field>
        <field name="0" bits="5" access="R" reset="0" />
        <field name="mprven" bits="4" access="R/W" reset="0" >
            When 1, \Fmprv in \Rmstatus takes effect during debug mode.
            When 0, it is ignored during debug mode.
            Implementing this bit is optional.
            If not implemented it should be tied to 0.
	</field>
        <field name="nmip" bits="3" access="R" reset="0">
            When set, there is a Non-Maskable-Interrupt (NMI) pending for the hart.
            
            Since an NMI can indicate a hardware error condition,
            reliable debugging may no longer be possible once this bit becomes set.
            This is implementation-dependent.
        </field>
        <field name="step" bits="2" access="R/W" reset="0">
            When set and not in Debug Mode, the hart will only execute a single
            instruction and then enter Debug Mode.
            If the instruction does not complete due to an exception,
            the hart will immediately enter Debug Mode before executing
            the trap handler, with appropriate exception registers set.
        </field>
        <field name="prv" bits="1:0" access="R/W" reset="3">
            Contains the privilege level the hart was operating in when Debug
            Mode was entered. The encoding is described in Table
            \ref{tab:privlevel}.  A debugger can change this value to change
            the hart's privilege level when exiting Debug Mode.

            Not all privilege levels are supported on all harts. If the
            encoding written is not supported or the debugger is not allowed to
            change to it, the hart may change to any supported privilege level.
        </field>
    </register>

    <register name="Debug PC" short="dpc" address="0x7b1">
        Upon entry to debug mode, \Rdpc is updated with the virtual address of
        the next instruction to be executed. The behavior is described in more
        detail in Table~\ref{tab:dpc}.

        \begin{table}[H]
        \centering
        \caption{Virtual address in DPC upon Debug Mode Entry}
        \label{tab:dpc}
        \begin{tabular}{|l|L|}
        \hline
        Cause &amp; Virtual Address in DPC \\
        \hline
        {\tt ebreak} &amp; Address of the {\tt ebreak} instruction \\
        \hline
        single step &amp; Address of the instruction that would be executed
        next if no debugging was going on. Ie. $\Rpc+4$ for 32-bit instructions
        that don't change program flow, the destination PC on taken
        jumps/branches, etc. \\
        \hline
        trigger module &amp; If \Ftiming is 0, the address of the
        instruction which caused the trigger to fire. If \Ftiming is 1, the
        address of the next instruction to be executed at the time that
        debug mode was entered. \\
        \hline
        halt request &amp; Address of the next instruction to be
        executed at the time that debug mode was entered \\
        \hline
        \end{tabular}
        \end{table}

        When resuming, the hart's PC is updated to the virtual address stored in
        \Rdpc. A debugger may write \Rdpc to change where the hart resumes.
        <field name="dpc" bits="MXLEN-1:0" access="R/W" reset="0" />
    </register>

    <register name="Debug Scratch Register 0" short="dscratch0" address="0x7b2">
        Optional scratch register that can be used by implementations that need
        it. A debugger must not write to this register unless \Rhartinfo
        explicitly mentions it (the Debug Module may use this register internally).
    </register>

    <register name="Debug Scratch Register 1" short="dscratch1" address="0x7b3">
        Optional scratch register that can be used by implementations that need
        it. A debugger must not write to this register unless \Rhartinfo
        explicitly mentions it (the Debug Module may use this register internally).
    </register>
</registers>
